// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: other_strings.proto

package cases_custom

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// define the regex for a UUID once up-front
var _other_strings_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on StringNone with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringNone) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Val

	return nil
}

// StringNoneValidationError is the validation error returned by
// StringNone.Validate if the designated constraints aren't met.
type StringNoneValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringNoneValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringNoneValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringNoneValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringNoneValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringNoneValidationError) ErrorName() string { return "StringNoneValidationError" }

// Error satisfies the builtin error interface
func (e StringNoneValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringNone.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringNoneValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringNoneValidationError{}

// Validate checks the field values on StringConst with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringConst) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetVal() != "foo" {
		return StringConstValidationError{
			field:  "Val",
			reason: "value must equal foo",
		}
	}

	return nil
}

// StringConstValidationError is the validation error returned by
// StringConst.Validate if the designated constraints aren't met.
type StringConstValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringConstValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringConstValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringConstValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringConstValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringConstValidationError) ErrorName() string { return "StringConstValidationError" }

// Error satisfies the builtin error interface
func (e StringConstValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringConst.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringConstValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringConstValidationError{}

// Validate checks the field values on StringIn with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringIn) Validate() error {
	if m == nil {
		return nil
	}

	if _, ok := _StringIn_Val_InLookup[m.GetVal()]; !ok {
		return StringInValidationError{
			field:  "Val",
			reason: "value must be in list [bar baz]",
		}
	}

	return nil
}

// StringInValidationError is the validation error returned by
// StringIn.Validate if the designated constraints aren't met.
type StringInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringInValidationError) ErrorName() string { return "StringInValidationError" }

// Error satisfies the builtin error interface
func (e StringInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringInValidationError{}

var _StringIn_Val_InLookup = map[string]struct{}{
	"bar": {},
	"baz": {},
}

// Validate checks the field values on StringNotIn with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringNotIn) Validate() error {
	if m == nil {
		return nil
	}

	if _, ok := _StringNotIn_Val_NotInLookup[m.GetVal()]; ok {
		return StringNotInValidationError{
			field:  "Val",
			reason: "value must not be in list [fizz buzz]",
		}
	}

	return nil
}

// StringNotInValidationError is the validation error returned by
// StringNotIn.Validate if the designated constraints aren't met.
type StringNotInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringNotInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringNotInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringNotInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringNotInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringNotInValidationError) ErrorName() string { return "StringNotInValidationError" }

// Error satisfies the builtin error interface
func (e StringNotInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringNotIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringNotInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringNotInValidationError{}

var _StringNotIn_Val_NotInLookup = map[string]struct{}{
	"fizz": {},
	"buzz": {},
}

// Validate checks the field values on StringLen with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringLen) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetVal()) != 3 {
		return StringLenValidationError{
			field:  "Val",
			reason: "value length must be 3 runes",
		}

	}

	return nil
}

// StringLenValidationError is the validation error returned by
// StringLen.Validate if the designated constraints aren't met.
type StringLenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringLenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringLenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringLenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringLenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringLenValidationError) ErrorName() string { return "StringLenValidationError" }

// Error satisfies the builtin error interface
func (e StringLenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringLen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringLenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringLenValidationError{}

// Validate checks the field values on StringMinLen with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringMinLen) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetVal()) < 3 {
		return StringMinLenValidationError{
			field:  "Val",
			reason: "value length must be at least 3 runes",
		}
	}

	return nil
}

// StringMinLenValidationError is the validation error returned by
// StringMinLen.Validate if the designated constraints aren't met.
type StringMinLenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMinLenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMinLenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMinLenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMinLenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMinLenValidationError) ErrorName() string { return "StringMinLenValidationError" }

// Error satisfies the builtin error interface
func (e StringMinLenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMinLen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMinLenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMinLenValidationError{}

// Validate checks the field values on StringMaxLen with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringMaxLen) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetVal()) > 5 {
		return StringMaxLenValidationError{
			field:  "Val",
			reason: "value length must be at most 5 runes",
		}
	}

	return nil
}

// StringMaxLenValidationError is the validation error returned by
// StringMaxLen.Validate if the designated constraints aren't met.
type StringMaxLenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMaxLenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMaxLenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMaxLenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMaxLenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMaxLenValidationError) ErrorName() string { return "StringMaxLenValidationError" }

// Error satisfies the builtin error interface
func (e StringMaxLenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMaxLen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMaxLenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMaxLenValidationError{}

// Validate checks the field values on StringMinMaxLen with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *StringMinMaxLen) Validate() error {
	if m == nil {
		return nil
	}

	if l := utf8.RuneCountInString(m.GetVal()); l < 3 || l > 5 {
		return StringMinMaxLenValidationError{
			field:  "Val",
			reason: "value length must be between 3 and 5 runes, inclusive",
		}
	}

	return nil
}

// StringMinMaxLenValidationError is the validation error returned by
// StringMinMaxLen.Validate if the designated constraints aren't met.
type StringMinMaxLenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMinMaxLenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMinMaxLenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMinMaxLenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMinMaxLenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMinMaxLenValidationError) ErrorName() string { return "StringMinMaxLenValidationError" }

// Error satisfies the builtin error interface
func (e StringMinMaxLenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMinMaxLen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMinMaxLenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMinMaxLenValidationError{}

// Validate checks the field values on StringEqualMinMaxLen with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *StringEqualMinMaxLen) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetVal()) != 5 {
		return StringEqualMinMaxLenValidationError{
			field:  "Val",
			reason: "value length must be 5 runes",
		}

	}

	return nil
}

// StringEqualMinMaxLenValidationError is the validation error returned by
// StringEqualMinMaxLen.Validate if the designated constraints aren't met.
type StringEqualMinMaxLenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringEqualMinMaxLenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringEqualMinMaxLenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringEqualMinMaxLenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringEqualMinMaxLenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringEqualMinMaxLenValidationError) ErrorName() string {
	return "StringEqualMinMaxLenValidationError"
}

// Error satisfies the builtin error interface
func (e StringEqualMinMaxLenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringEqualMinMaxLen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringEqualMinMaxLenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringEqualMinMaxLenValidationError{}

// Validate checks the field values on StringLenBytes with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringLenBytes) Validate() error {
	if m == nil {
		return nil
	}

	if len(m.GetVal()) != 4 {
		return StringLenBytesValidationError{
			field:  "Val",
			reason: "value length must be 4 bytes",
		}
	}

	return nil
}

// StringLenBytesValidationError is the validation error returned by
// StringLenBytes.Validate if the designated constraints aren't met.
type StringLenBytesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringLenBytesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringLenBytesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringLenBytesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringLenBytesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringLenBytesValidationError) ErrorName() string { return "StringLenBytesValidationError" }

// Error satisfies the builtin error interface
func (e StringLenBytesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringLenBytes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringLenBytesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringLenBytesValidationError{}

// Validate checks the field values on StringMinBytes with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringMinBytes) Validate() error {
	if m == nil {
		return nil
	}

	if len(m.GetVal()) < 4 {
		return StringMinBytesValidationError{
			field:  "Val",
			reason: "value length must be at least 4 bytes",
		}
	}

	return nil
}

// StringMinBytesValidationError is the validation error returned by
// StringMinBytes.Validate if the designated constraints aren't met.
type StringMinBytesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMinBytesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMinBytesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMinBytesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMinBytesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMinBytesValidationError) ErrorName() string { return "StringMinBytesValidationError" }

// Error satisfies the builtin error interface
func (e StringMinBytesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMinBytes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMinBytesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMinBytesValidationError{}

// Validate checks the field values on StringMaxBytes with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringMaxBytes) Validate() error {
	if m == nil {
		return nil
	}

	if len(m.GetVal()) > 8 {
		return StringMaxBytesValidationError{
			field:  "Val",
			reason: "value length must be at most 8 bytes",
		}
	}

	return nil
}

// StringMaxBytesValidationError is the validation error returned by
// StringMaxBytes.Validate if the designated constraints aren't met.
type StringMaxBytesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMaxBytesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMaxBytesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMaxBytesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMaxBytesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMaxBytesValidationError) ErrorName() string { return "StringMaxBytesValidationError" }

// Error satisfies the builtin error interface
func (e StringMaxBytesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMaxBytes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMaxBytesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMaxBytesValidationError{}

// Validate checks the field values on StringMinMaxBytes with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *StringMinMaxBytes) Validate() error {
	if m == nil {
		return nil
	}

	if l := len(m.GetVal()); l < 4 || l > 8 {
		return StringMinMaxBytesValidationError{
			field:  "Val",
			reason: "value length must be between 4 and 8 bytes, inclusive",
		}
	}

	return nil
}

// StringMinMaxBytesValidationError is the validation error returned by
// StringMinMaxBytes.Validate if the designated constraints aren't met.
type StringMinMaxBytesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMinMaxBytesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMinMaxBytesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMinMaxBytesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMinMaxBytesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMinMaxBytesValidationError) ErrorName() string {
	return "StringMinMaxBytesValidationError"
}

// Error satisfies the builtin error interface
func (e StringMinMaxBytesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMinMaxBytes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMinMaxBytesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMinMaxBytesValidationError{}

// Validate checks the field values on StringEqualMinMaxBytes with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *StringEqualMinMaxBytes) Validate() error {
	if m == nil {
		return nil
	}

	if l := len(m.GetVal()); l < 4 || l > 8 {
		return StringEqualMinMaxBytesValidationError{
			field:  "Val",
			reason: "value length must be between 4 and 8 bytes, inclusive",
		}
	}

	return nil
}

// StringEqualMinMaxBytesValidationError is the validation error returned by
// StringEqualMinMaxBytes.Validate if the designated constraints aren't met.
type StringEqualMinMaxBytesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringEqualMinMaxBytesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringEqualMinMaxBytesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringEqualMinMaxBytesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringEqualMinMaxBytesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringEqualMinMaxBytesValidationError) ErrorName() string {
	return "StringEqualMinMaxBytesValidationError"
}

// Error satisfies the builtin error interface
func (e StringEqualMinMaxBytesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringEqualMinMaxBytes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringEqualMinMaxBytesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringEqualMinMaxBytesValidationError{}

// Validate checks the field values on StringPattern with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringPattern) Validate() error {
	if m == nil {
		return nil
	}

	if !_StringPattern_Val_Pattern.MatchString(m.GetVal()) {
		return StringPatternValidationError{
			field:  "Val",
			reason: "value does not match regex pattern \"(?i)^[a-z0-9]+$\"",
		}
	}

	return nil
}

// StringPatternValidationError is the validation error returned by
// StringPattern.Validate if the designated constraints aren't met.
type StringPatternValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringPatternValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringPatternValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringPatternValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringPatternValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringPatternValidationError) ErrorName() string { return "StringPatternValidationError" }

// Error satisfies the builtin error interface
func (e StringPatternValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringPattern.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringPatternValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringPatternValidationError{}

var _StringPattern_Val_Pattern = regexp.MustCompile("(?i)^[a-z0-9]+$")

// Validate checks the field values on StringPatternEscapes with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *StringPatternEscapes) Validate() error {
	if m == nil {
		return nil
	}

	if !_StringPatternEscapes_Val_Pattern.MatchString(m.GetVal()) {
		return StringPatternEscapesValidationError{
			field:  "Val",
			reason: "value does not match regex pattern \"\\\\* \\\\\\\\ \\\\w\"",
		}
	}

	return nil
}

// StringPatternEscapesValidationError is the validation error returned by
// StringPatternEscapes.Validate if the designated constraints aren't met.
type StringPatternEscapesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringPatternEscapesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringPatternEscapesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringPatternEscapesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringPatternEscapesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringPatternEscapesValidationError) ErrorName() string {
	return "StringPatternEscapesValidationError"
}

// Error satisfies the builtin error interface
func (e StringPatternEscapesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringPatternEscapes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringPatternEscapesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringPatternEscapesValidationError{}

var _StringPatternEscapes_Val_Pattern = regexp.MustCompile("\\* \\\\ \\w")

// Validate checks the field values on StringPrefix with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringPrefix) Validate() error {
	if m == nil {
		return nil
	}

	if !strings.HasPrefix(m.GetVal(), "foo") {
		return StringPrefixValidationError{
			field:  "Val",
			reason: "value does not have prefix \"foo\"",
		}
	}

	return nil
}

// StringPrefixValidationError is the validation error returned by
// StringPrefix.Validate if the designated constraints aren't met.
type StringPrefixValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringPrefixValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringPrefixValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringPrefixValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringPrefixValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringPrefixValidationError) ErrorName() string { return "StringPrefixValidationError" }

// Error satisfies the builtin error interface
func (e StringPrefixValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringPrefix.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringPrefixValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringPrefixValidationError{}

// Validate checks the field values on StringContains with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringContains) Validate() error {
	if m == nil {
		return nil
	}

	if !strings.Contains(m.GetVal(), "bar") {
		return StringContainsValidationError{
			field:  "Val",
			reason: "value does not contain substring \"bar\"",
		}
	}

	return nil
}

// StringContainsValidationError is the validation error returned by
// StringContains.Validate if the designated constraints aren't met.
type StringContainsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringContainsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringContainsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringContainsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringContainsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringContainsValidationError) ErrorName() string { return "StringContainsValidationError" }

// Error satisfies the builtin error interface
func (e StringContainsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringContains.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringContainsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringContainsValidationError{}

// Validate checks the field values on StringNotContains with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *StringNotContains) Validate() error {
	if m == nil {
		return nil
	}

	if strings.Contains(m.GetVal(), "bar") {
		return StringNotContainsValidationError{
			field:  "Val",
			reason: "value contains substring \"bar\"",
		}
	}

	return nil
}

// StringNotContainsValidationError is the validation error returned by
// StringNotContains.Validate if the designated constraints aren't met.
type StringNotContainsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringNotContainsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringNotContainsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringNotContainsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringNotContainsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringNotContainsValidationError) ErrorName() string {
	return "StringNotContainsValidationError"
}

// Error satisfies the builtin error interface
func (e StringNotContainsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringNotContains.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringNotContainsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringNotContainsValidationError{}

// Validate checks the field values on StringSuffix with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringSuffix) Validate() error {
	if m == nil {
		return nil
	}

	if !strings.HasSuffix(m.GetVal(), "baz") {
		return StringSuffixValidationError{
			field:  "Val",
			reason: "value does not have suffix \"baz\"",
		}
	}

	return nil
}

// StringSuffixValidationError is the validation error returned by
// StringSuffix.Validate if the designated constraints aren't met.
type StringSuffixValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringSuffixValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringSuffixValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringSuffixValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringSuffixValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringSuffixValidationError) ErrorName() string { return "StringSuffixValidationError" }

// Error satisfies the builtin error interface
func (e StringSuffixValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringSuffix.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringSuffixValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringSuffixValidationError{}

// Validate checks the field values on StringEmail with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringEmail) Validate() error {
	if m == nil {
		return nil
	}

	if err := m._validateEmail(m.GetVal()); err != nil {
		return StringEmailValidationError{
			field:  "Val",
			reason: "value must be a valid email address",
			cause:  err,
		}
	}

	return nil
}

func (m *StringEmail) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *StringEmail) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// StringEmailValidationError is the validation error returned by
// StringEmail.Validate if the designated constraints aren't met.
type StringEmailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringEmailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringEmailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringEmailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringEmailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringEmailValidationError) ErrorName() string { return "StringEmailValidationError" }

// Error satisfies the builtin error interface
func (e StringEmailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringEmail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringEmailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringEmailValidationError{}

// Validate checks the field values on StringAddress with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringAddress) Validate() error {
	if m == nil {
		return nil
	}

	if err := m._validateHostname(m.GetVal()); err != nil {
		if ip := net.ParseIP(m.GetVal()); ip == nil {
			return StringAddressValidationError{
				field:  "Val",
				reason: "value must be a valid hostname, or ip address",
			}
		}
	}

	return nil
}

func (m *StringAddress) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// StringAddressValidationError is the validation error returned by
// StringAddress.Validate if the designated constraints aren't met.
type StringAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringAddressValidationError) ErrorName() string { return "StringAddressValidationError" }

// Error satisfies the builtin error interface
func (e StringAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringAddressValidationError{}

// Validate checks the field values on StringHostname with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringHostname) Validate() error {
	if m == nil {
		return nil
	}

	if err := m._validateHostname(m.GetVal()); err != nil {
		return StringHostnameValidationError{
			field:  "Val",
			reason: "value must be a valid hostname",
			cause:  err,
		}
	}

	return nil
}

func (m *StringHostname) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// StringHostnameValidationError is the validation error returned by
// StringHostname.Validate if the designated constraints aren't met.
type StringHostnameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringHostnameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringHostnameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringHostnameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringHostnameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringHostnameValidationError) ErrorName() string { return "StringHostnameValidationError" }

// Error satisfies the builtin error interface
func (e StringHostnameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringHostname.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringHostnameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringHostnameValidationError{}

// Validate checks the field values on StringIP with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringIP) Validate() error {
	if m == nil {
		return nil
	}

	if ip := net.ParseIP(m.GetVal()); ip == nil {
		return StringIPValidationError{
			field:  "Val",
			reason: "value must be a valid IP address",
		}
	}

	return nil
}

// StringIPValidationError is the validation error returned by
// StringIP.Validate if the designated constraints aren't met.
type StringIPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringIPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringIPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringIPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringIPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringIPValidationError) ErrorName() string { return "StringIPValidationError" }

// Error satisfies the builtin error interface
func (e StringIPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringIP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringIPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringIPValidationError{}

// Validate checks the field values on StringIPv4 with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringIPv4) Validate() error {
	if m == nil {
		return nil
	}

	if ip := net.ParseIP(m.GetVal()); ip == nil || ip.To4() == nil {
		return StringIPv4ValidationError{
			field:  "Val",
			reason: "value must be a valid IPv4 address",
		}
	}

	return nil
}

// StringIPv4ValidationError is the validation error returned by
// StringIPv4.Validate if the designated constraints aren't met.
type StringIPv4ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringIPv4ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringIPv4ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringIPv4ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringIPv4ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringIPv4ValidationError) ErrorName() string { return "StringIPv4ValidationError" }

// Error satisfies the builtin error interface
func (e StringIPv4ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringIPv4.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringIPv4ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringIPv4ValidationError{}

// Validate checks the field values on StringIPv6 with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringIPv6) Validate() error {
	if m == nil {
		return nil
	}

	if ip := net.ParseIP(m.GetVal()); ip == nil || ip.To4() != nil {
		return StringIPv6ValidationError{
			field:  "Val",
			reason: "value must be a valid IPv6 address",
		}
	}

	return nil
}

// StringIPv6ValidationError is the validation error returned by
// StringIPv6.Validate if the designated constraints aren't met.
type StringIPv6ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringIPv6ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringIPv6ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringIPv6ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringIPv6ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringIPv6ValidationError) ErrorName() string { return "StringIPv6ValidationError" }

// Error satisfies the builtin error interface
func (e StringIPv6ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringIPv6.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringIPv6ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringIPv6ValidationError{}

// Validate checks the field values on StringURI with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringURI) Validate() error {
	if m == nil {
		return nil
	}

	if uri, err := url.Parse(m.GetVal()); err != nil {
		return StringURIValidationError{
			field:  "Val",
			reason: "value must be a valid URI",
			cause:  err,
		}
	} else if !uri.IsAbs() {
		return StringURIValidationError{
			field:  "Val",
			reason: "value must be absolute",
		}
	}

	return nil
}

// StringURIValidationError is the validation error returned by
// StringURI.Validate if the designated constraints aren't met.
type StringURIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringURIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringURIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringURIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringURIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringURIValidationError) ErrorName() string { return "StringURIValidationError" }

// Error satisfies the builtin error interface
func (e StringURIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringURI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringURIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringURIValidationError{}

// Validate checks the field values on StringURIRef with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringURIRef) Validate() error {
	if m == nil {
		return nil
	}

	if _, err := url.Parse(m.GetVal()); err != nil {
		return StringURIRefValidationError{
			field:  "Val",
			reason: "value must be a valid URI",
			cause:  err,
		}
	}

	return nil
}

// StringURIRefValidationError is the validation error returned by
// StringURIRef.Validate if the designated constraints aren't met.
type StringURIRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringURIRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringURIRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringURIRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringURIRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringURIRefValidationError) ErrorName() string { return "StringURIRefValidationError" }

// Error satisfies the builtin error interface
func (e StringURIRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringURIRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringURIRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringURIRefValidationError{}

// Validate checks the field values on StringUUID with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *StringUUID) Validate() error {
	if m == nil {
		return nil
	}

	if err := m._validateUuid(m.GetVal()); err != nil {
		return StringUUIDValidationError{
			field:  "Val",
			reason: "value must be a valid UUID",
			cause:  err,
		}
	}

	return nil
}

func (m *StringUUID) _validateUuid(uuid string) error {
	if matched := _other_strings_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// StringUUIDValidationError is the validation error returned by
// StringUUID.Validate if the designated constraints aren't met.
type StringUUIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringUUIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringUUIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringUUIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringUUIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringUUIDValidationError) ErrorName() string { return "StringUUIDValidationError" }

// Error satisfies the builtin error interface
func (e StringUUIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringUUID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringUUIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringUUIDValidationError{}

// Validate checks the field values on StringHttpHeaderName with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *StringHttpHeaderName) Validate() error {
	if m == nil {
		return nil
	}

	if !_StringHttpHeaderName_Val_Pattern.MatchString(m.GetVal()) {
		return StringHttpHeaderNameValidationError{
			field:  "Val",
			reason: "value does not match regex pattern \"^:?[0-9a-zA-Z!#$%&'*+-.^_|~`]+$\"",
		}
	}

	return nil
}

// StringHttpHeaderNameValidationError is the validation error returned by
// StringHttpHeaderName.Validate if the designated constraints aren't met.
type StringHttpHeaderNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringHttpHeaderNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringHttpHeaderNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringHttpHeaderNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringHttpHeaderNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringHttpHeaderNameValidationError) ErrorName() string {
	return "StringHttpHeaderNameValidationError"
}

// Error satisfies the builtin error interface
func (e StringHttpHeaderNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringHttpHeaderName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringHttpHeaderNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringHttpHeaderNameValidationError{}

var _StringHttpHeaderName_Val_Pattern = regexp.MustCompile("^:?[0-9a-zA-Z!#$%&'*+-.^_|~`]+$")

// Validate checks the field values on StringHttpHeaderValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *StringHttpHeaderValue) Validate() error {
	if m == nil {
		return nil
	}

	if !_StringHttpHeaderValue_Val_Pattern.MatchString(m.GetVal()) {
		return StringHttpHeaderValueValidationError{
			field:  "Val",
			reason: "value does not match regex pattern \"^[^\\x00-\\b\\n-\\x1f\\u007f]*$\"",
		}
	}

	return nil
}

// StringHttpHeaderValueValidationError is the validation error returned by
// StringHttpHeaderValue.Validate if the designated constraints aren't met.
type StringHttpHeaderValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringHttpHeaderValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringHttpHeaderValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringHttpHeaderValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringHttpHeaderValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringHttpHeaderValueValidationError) ErrorName() string {
	return "StringHttpHeaderValueValidationError"
}

// Error satisfies the builtin error interface
func (e StringHttpHeaderValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringHttpHeaderValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringHttpHeaderValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringHttpHeaderValueValidationError{}

var _StringHttpHeaderValue_Val_Pattern = regexp.MustCompile("^[^\x00-\b\n-\x1f\u007f]*$")

// Validate checks the field values on StringValidHeader with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *StringValidHeader) Validate() error {
	if m == nil {
		return nil
	}

	if !_StringValidHeader_Val_Pattern.MatchString(m.GetVal()) {
		return StringValidHeaderValidationError{
			field:  "Val",
			reason: "value does not match regex pattern \"^[^\\x00\\n\\r]*$\"",
		}
	}

	return nil
}

// StringValidHeaderValidationError is the validation error returned by
// StringValidHeader.Validate if the designated constraints aren't met.
type StringValidHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringValidHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringValidHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringValidHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringValidHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringValidHeaderValidationError) ErrorName() string {
	return "StringValidHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e StringValidHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringValidHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringValidHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringValidHeaderValidationError{}

var _StringValidHeader_Val_Pattern = regexp.MustCompile("^[^\x00\n\r]*$")
